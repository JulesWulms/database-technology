In this section we describe the problem that is addressed in the paper, but we also state the solution that the authors proposed. We choose to do this, since the solution in the paper is actually part of our own validation problem.

As mentioned in the "Project Pushing Revisited" paper~\cite{paper}, \textit{join} operation is one of the most fundamental and most expensive operations in a database query. The reason is the fact that it combines and uses tuples from multiple relations. In the research of the paper~\cite{paper}, an attempt is made, which focuses on structural query properties, to find the \textit{project} - \textit{join} order, which will utilize the size of intermediate results during query evaluation, in the terms of minimization. \\

In general, almost every database query can be expressed as a \textit{select} - \textit{project} â€“ \textit{join} query, which combine \textit{joins} with \textit{selections} and \textit{projections}. The main idea of the research is to choose a \textit{project} - \textit{join} order, which will establish a linear bound on the size of intermediate results. More specifically, it is proven experimentally by the authors that a standard SQL planner spends an exponential amount of time on generating plans for such queries, with rather dismal results in terms of performance and without taking advantage of projection pushing. So the main focus of whole project is to study the scalability of various optimizing methods and to compare the performance of different optimization techniques when the size of the queries is increased. \\

Below we give a description of the techniques, which were tested during the papers~\cite{paper} research, in order to clarify what will be verified in our own research. The following techniques must be implemented for verification. More specifically, the techniques, which will be tested, are the following:

\begin{itemize}
	\item Na\"ive approach
	\item Straightforward approach
	\item Projection Pushing and Join Reordering
	\item Bucket Elimination
\end{itemize}

These methods will be tested on queries that solve the 3-COLOUR graph problem. The goal is to find a label out of a set of three different labels, such that each pair of vertices that have an edge between them, do not have the same label. This is realised by creating a table for each possible edge, which has a record for each possible, valid colouring for these two graphs. This comes down to a table of 6 records, which are all possible combinations of 2 different colours out of the 3 possible ones. If we now try to join all the tables for which there are edges in a graph, we solve the 3-COLOUR problem. When the join results in a table without records, there is no possible colouring, but when there are records, the values in the records give a correct colouring/labelling. \\

The Na\"ive approach constructs a query where all the tables are listed in the FROM section and in the WHERE section conditions are stated that show which attributes should be equal. The Straightforward approach suggests a specific query structure, which takes advantage of join operation, in order to minimize compile time. In the paper is stated that na\"ive queries are exceedingly difficult to compile and compile time is four orders of magnitude bigger than execution time. In order to get around this ineffectiveness, researchers propose to explicitly list the \textit{joins} in the FROM section of the query, instead of using equalities in the WHERE section as in the naive approach. In this case, the order in which the relations are listed then becomes the order that the database engine evaluates the query. This technique effectively limits what SQL Planner can do and therefore drastically decreases compile time. However, the straightforward approach still does not take advantage of projection pushing. Consequently, it was found that query execution time for the naive and straightforward approaches are essentially identical; the join order chosen by the genetic algorithm is apparently no better than the straightforward order. \\

Projection Pushing is a step further than the straightforward approach. The idea is to produce an early projection, which would reduce the size of intermediate results by reducing their arity, making further joins less expensive, and thus reducing execution time of the query. Early projection in SQL can be implemented with the use of sub-queries. This method processes the relations of the query in a linear fashion, but it can be optimized further. Since the goal of early projection is to project variables as soon as possible, reordering the relations may enable us to project early more aggressively. So, it would be more effective if there is a search at each step for an atom that would result in the maximum number of variables to be projected early. According to Join Reordering, a permutation could be chosen so as to minimize the number of live variables into intermediate relations. Once this permutation is computed, the same SQL query can be constructed as before, but this time with permutation order. \\